{
  "$schema": "https://the-aico.com/schema/employee.json",
  "name": "backend",
  "role": "Backend Engineer",
  "description": "Full-stack backend development: API design, database, business logic, TDD, and system architecture",
  "skills": [
    {
      "name": "init",
      "files": [
        {
          "path": "skills/init/SKILL.md",
          "type": "skill",
          "content": "---\nname: aico-backend-init\ndescription: |\n  Initialize backend environment by creating constraints document from template.\n\n  Use this skill when:\n  - Running /backend.init command\n  - User asks to \"initialize backend\", \"setup backend environment\"\n  - Starting backend work and need to establish tech stack and conventions\n  - Need to create docs/reference/backend/constraints.md\n---\n\n# Backend Init\n\nInitialize backend development environment by creating the constraints file.\n\n## Language Configuration\n\nBefore generating any content, check `aico.json` in project root for `language` field to determine the output language. If not set, default to English.\n\n## Process\n\n1. **Check existing**: Look for `docs/reference/backend/constraints.md`\n2. **If exists**: Ask user if they want to overwrite or skip\n3. **Create directory structure**:\n   ```\n   docs/reference/backend/\n   ├── constraints.md\n   └── tasks/\n   ```\n4. **Generate constraints file**:\n   - Read template from `references/constraints.template.md`\n   - Guide user through key decisions\n5. **Save output**: Write to `docs/reference/backend/constraints.md`\n\n## Document Header Format\n\nAll generated documents MUST use this unified header format:\n\n```markdown\n# [Document Title]\n\n> Project: [project-name]\n> Created: YYYY-MM-DD\n> Last Updated: YYYY-MM-DD\n```\n\n## Guided Questions\n\n| Category         | Questions                          |\n| ---------------- | ---------------------------------- |\n| Language/Runtime | Node.js, Python, Go, Rust?         |\n| Framework        | Express, Fastify, FastAPI, Gin?    |\n| Database         | PostgreSQL, MySQL, MongoDB?        |\n| ORM/Query        | Prisma, Drizzle, SQLAlchemy, GORM? |\n| Testing          | Vitest, Jest, Pytest, Go test?     |\n| API Style        | REST, GraphQL, gRPC?               |\n\n## Template\n\nSee `references/constraints.template.md` for the full constraints template.\n\n## Output\n\n```\n✓ Created docs/reference/backend/constraints.md\n✓ Created docs/reference/backend/tasks/\n✓ Backend environment initialized\n```\n\n## Key Rules\n\n- ALWAYS use the unified header format\n- MUST guide user through tech stack questions\n- ALWAYS create tasks/ directory\n- ALWAYS save to `docs/reference/backend/constraints.md`\n"
        },
        {
          "path": "skills/init/references/constraints.template.md",
          "type": "doc",
          "content": "# Backend Constraints\n\n> Project: [PROJECT_NAME]\n> Created: [CREATED_DATE]\n> Last Updated: [UPDATED_DATE]\n\n## Tech Stack\n\n### Language & Runtime\n\n| Item            | Value                                 |\n| --------------- | ------------------------------------- |\n| Language        | TypeScript / Python / Go              |\n| Runtime         | Node.js 20+ / Python 3.11+ / Go 1.21+ |\n| Package Manager | pnpm / npm / pip / go mod             |\n\n### Framework\n\n| Item          | Value                                    |\n| ------------- | ---------------------------------------- |\n| Web Framework | Express / Fastify / FastAPI / Gin        |\n| Validation    | Zod / Pydantic / go-playground/validator |\n| ORM/Query     | Prisma / Drizzle / SQLAlchemy / GORM     |\n\n### Database\n\n| Item       | Value                                     |\n| ---------- | ----------------------------------------- |\n| Primary DB | PostgreSQL / MySQL / MongoDB              |\n| Cache      | Redis / Memcached                         |\n| Migrations | Prisma Migrate / Alembic / golang-migrate |\n\n## Architecture\n\n### API Style\n\n- [ ] REST\n- [ ] GraphQL\n- [ ] gRPC\n- [ ] WebSocket\n\n### Layered Architecture\n\n```\nController/Handler (HTTP layer)\n       ↓\n    Service (Business logic)\n       ↓\n   Repository (Data access)\n       ↓\n    Database\n```\n\n### Directory Structure\n\n```\nsrc/\n├── controllers/     # HTTP handlers\n├── services/        # Business logic\n├── repositories/    # Data access\n├── models/          # Database models\n├── types/           # TypeScript types/interfaces\n├── middleware/      # Express/Fastify middleware\n├── utils/           # Utility functions\n└── config/          # Configuration\n```\n\n## Coding Standards\n\n### Naming Conventions\n\n| Type            | Convention  | Example           |\n| --------------- | ----------- | ----------------- |\n| Files           | kebab-case  | `user-service.ts` |\n| Classes         | PascalCase  | `UserService`     |\n| Functions       | camelCase   | `createUser`      |\n| Constants       | UPPER_SNAKE | `MAX_RETRIES`     |\n| Database tables | snake_case  | `user_sessions`   |\n\n### Code Style\n\n- Use ESLint/Prettier (TS), Ruff (Python), golangci-lint (Go)\n- Max line length: 100 characters\n- Use async/await over callbacks\n- Explicit error handling (no silent failures)\n\n## Testing\n\n### Framework\n\n| Type        | Tool                             |\n| ----------- | -------------------------------- |\n| Unit Tests  | Jest / Vitest / Pytest / Go test |\n| Integration | Supertest / httptest             |\n| Mocking     | jest.mock / unittest.mock        |\n\n### Requirements\n\n- [ ] All services must have unit tests\n- [ ] All API endpoints must have integration tests\n- [ ] Minimum 80% code coverage\n- [ ] TDD: Write failing test before implementation\n\n### Test Structure\n\n```\nsrc/\n├── services/\n│   ├── user.service.ts\n│   └── __tests__/\n│       └── user.service.test.ts\n```\n\n## Security\n\n### Authentication\n\n- [ ] JWT tokens\n- [ ] Session-based\n- [ ] OAuth 2.0\n- [ ] API keys\n\n### Password Handling\n\n- Use bcrypt with cost factor 10+\n- Never store plaintext passwords\n- Never log passwords\n\n### Input Validation\n\n- Validate all inputs at API boundary\n- Use schema validation (Zod/Pydantic)\n- Sanitize user inputs\n\n### OWASP Top 10\n\n- [ ] SQL Injection: Use parameterized queries\n- [ ] XSS: Escape output, use Content-Security-Policy\n- [ ] CSRF: Use CSRF tokens for state-changing operations\n- [ ] Auth: Secure session management\n\n## Error Handling\n\n### Error Response Format\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Email is required\",\n    \"details\": [...]\n  }\n}\n```\n\n### HTTP Status Codes\n\n| Code | Usage                          |\n| ---- | ------------------------------ |\n| 200  | Success                        |\n| 201  | Created                        |\n| 400  | Bad Request (validation error) |\n| 401  | Unauthorized                   |\n| 403  | Forbidden                      |\n| 404  | Not Found                      |\n| 500  | Internal Server Error          |\n\n## Logging\n\n### Format\n\n```json\n{\n  \"timestamp\": \"2024-01-01T00:00:00Z\",\n  \"level\": \"info\",\n  \"message\": \"User created\",\n  \"context\": { \"userId\": \"123\" }\n}\n```\n\n### Levels\n\n| Level | Usage                        |\n| ----- | ---------------------------- |\n| error | Errors requiring attention   |\n| warn  | Warnings, degraded operation |\n| info  | Normal operations            |\n| debug | Debugging information        |\n\n## Environment\n\n### Required Variables\n\n```bash\n# Database\nDATABASE_URL=postgresql://...\n\n# Auth\nJWT_SECRET=...\nJWT_EXPIRY=3600\n\n# Server\nPORT=3000\nNODE_ENV=development\n```\n\n### Configuration\n\n- Use environment variables for secrets\n- Use config files for non-sensitive settings\n- Never commit secrets to git\n\n## API Design\n\n### REST Conventions\n\n| Method | Path       | Action      |\n| ------ | ---------- | ----------- |\n| GET    | /users     | List users  |\n| GET    | /users/:id | Get user    |\n| POST   | /users     | Create user |\n| PUT    | /users/:id | Update user |\n| DELETE | /users/:id | Delete user |\n\n### Pagination\n\n```json\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 20,\n    \"total\": 100\n  }\n}\n```\n\n## Performance\n\n### Database\n\n- Use indexes for frequently queried columns\n- Avoid N+1 queries\n- Use connection pooling\n\n### Caching\n\n- Cache frequently accessed data\n- Set appropriate TTL\n- Invalidate on updates\n\n### Rate Limiting\n\n- Implement rate limiting for public APIs\n- Use sliding window algorithm\n- Return 429 Too Many Requests\n"
        }
      ]
    },
    {
      "name": "task-breakdown",
      "files": [
        {
          "path": "skills/task-breakdown/SKILL.md",
          "type": "skill",
          "content": "---\nname: aico-backend-task-breakdown\ndescription: |\n  Break down PM story into backend tasks following LAYERED ARCHITECTURE order: Data Models → Database → Repository → Service → API → Validation → Tests.\n\n  UNIQUE VALUE: Ensures proper dependency order and separation of concerns. Tasks are ordered by architectural layers, not random order.\n\n  Use this skill when:\n  - Running /backend.tasks command\n  - User asks to \"break down story for backend\", \"create backend tasks\", \"split into backend tasks\"\n  - Have story at docs/reference/pm/stories/ and need organized task list\n  - Need tasks ordered by architectural layers (not random order)\n  - Starting backend work and want organized, layered task list\n\n  Layer order is CRITICAL: Types/Entities → Migrations → Repository → Service → API → Validation → Tests\n  Output: ALWAYS write to docs/reference/backend/tasks/{story-name}.md\n---\n\n# Task Breakdown\n\n## Language Configuration\n\nBefore generating any content, check `aico.json` in project root for `language` field to determine the output language. If not set, default to English.\n\n## Process\n\n1. **Read story/PRD**: Load from `docs/reference/pm/stories/` or `docs/reference/pm/versions/`\n2. **Identify data entities**: What domain objects are needed\n3. **Identify API endpoints**: What routes are needed\n4. **Identify business logic**: What services are needed\n5. **Break into tasks**: Follow layered architecture order\n6. **Save output**: ALWAYS write to `docs/reference/backend/tasks/{story-name}.md`\n\n## Layered Architecture Order\n\n```\n1. Data Models (types, entities, DTOs)\n      ↓\n2. Database (migrations, schema)\n      ↓\n3. Repository Layer (data access)\n      ↓\n4. Service Layer (business logic)\n      ↓\n5. API Layer (controllers, routes)\n      ↓\n6. Validation & Error Handling\n      ↓\n7. Tests (unit, integration, API)\n```\n\n## Task File Template\n\n```markdown\n# [Story Name] - Backend Tasks\n\n> Project: [project-name]\n> Created: YYYY-MM-DD\n> Last Updated: YYYY-MM-DD\n> Source: docs/reference/pm/stories/[story].md\n> Status: in_progress\n\n## Progress\n\n| #   | Task                       | Status     | Notes |\n| --- | -------------------------- | ---------- | ----- |\n| 1   | Define data models         | ⏳ pending |       |\n| 2   | Create database migrations | ⏳ pending |       |\n| 3   | Implement repository layer | ⏳ pending |       |\n\n## Tasks\n\n### Task 1: Define data models\n\n**Status**: ⏳ pending\n**Goal**: Create types for domain entities\n**Scope**: Entity types, DTOs, validation schemas\n**Acceptance Criteria**:\n\n- [ ] Types match business requirements\n- [ ] No type errors\n      **Dependencies**: None\n```\n\n## Task Types\n\n| Type       | Examples                       |\n| ---------- | ------------------------------ |\n| Data Model | Define entities, DTOs, schemas |\n| Database   | Migrations, indexes, seeds     |\n| Repository | Data access layer              |\n| Service    | Business logic                 |\n| API        | Controllers, routes            |\n| Validation | Input validation               |\n| Testing    | Unit, integration, API tests   |\n\n## Granularity Rules\n\n- Each task = independently testable\n- Each task = single responsibility\n- Each task = clear scope (not too big, not too small)\n\n## Key Rules\n\n- ALWAYS follow layered architecture order\n- MUST include test tasks for each layer\n- ALWAYS note dependencies between tasks\n- MUST save to `docs/reference/backend/tasks/` directory\n\n## Common Mistakes\n\n- ❌ Tasks too large (entire API) → ✅ Break into layers\n- ❌ Skip data model first → ✅ Types before implementation\n- ❌ Skip repository layer → ✅ Separate data access\n- ❌ Forget validation → ✅ Always include validation task\n"
        }
      ]
    },
    {
      "name": "plan",
      "files": [
        {
          "path": "skills/plan/SKILL.md",
          "type": "skill",
          "content": "---\nname: aico-backend-plan\ndescription: |\n  Create ATOMIC implementation plan for a single backend task. Each step has TDD, exact code, and verification command.\n\n  IMPORTANT: This skill creates MICRO-LEVEL atomic steps, NOT macro architecture plans.\n  For architecture planning or feature scoping, use EnterPlanMode instead.\n\n  Use this skill when:\n  - Running /backend.plan command\n  - User explicitly asks for \"atomic steps\", \"step-by-step plan with verification\"\n  - Have a specific task from docs/reference/backend/tasks/ and need implementation steps\n  - Need granular TDD steps: Types → DB → Test (failing) → Implementation → Test (passing) → API\n\n  DO NOT use for:\n  - Architecture planning (use EnterPlanMode)\n  - General development planning\n  - Feature scoping or estimation\n\n  Output: Present plan to user (not saved to file), each step includes Files, Action, and Verify command.\n---\n\n# Plan\n\n## Language Configuration\n\nBefore generating any content, check `aico.json` in project root for `language` field to determine the output language. If not set, default to English.\n\n## Process\n\n1. **Read task**: Get details from `docs/reference/backend/tasks/{story}.md`\n2. **Read constraints**: Load `docs/reference/backend/constraints.md`\n3. **Break into atomic steps** following this order:\n   - Types/interfaces first\n   - Database migrations\n   - Failing tests (TDD)\n   - Implementation to pass tests\n   - API routes\n   - Verification\n4. **Keep steps atomic**: One action per step\n5. **Present plan to user** (do not save to file)\n\n## Plan Format\n\n````markdown\n# [Task Name] - Implementation Plan\n\n> Project: [project-name]\n> Created: YYYY-MM-DD\n> Task: [task description]\n> Estimated steps: N\n\n## Step 1: [Action]\n\n**Files**:\n\n- Create: `src/types/user.ts`\n\n**Action**:\n[Exact code]\n\n**Verify**:\n\n```bash\nnpx tsc --noEmit\n```\n````\n\nExpected: No errors\n\n```\n\n## Step Order\n\n| Order | Step Type | Purpose |\n|-------|-----------|---------|\n| 1 | Types | Define interfaces and DTOs |\n| 2 | Database | Create migrations |\n| 3 | Test (RED) | Write failing test |\n| 4 | Implement (GREEN) | Write code to pass test |\n| 5 | API | Add routes |\n| 6 | Commit | Stage and commit |\n\n## Step Granularity\n\n| Good Steps | Bad Steps |\n|------------|-----------|\n| Create type file with interface | Create entire model with methods |\n| Write one failing test | Write all tests |\n| Implement single method | Implement entire service |\n| Add one route | Add all routes |\n\n## Key Rules\n\n- ALWAYS write failing test before implementation (TDD)\n- MUST include verification command for each step\n- ALWAYS follow order: Types → DB → Test → Impl → API\n- NEVER combine multiple actions into one step\n\n## Common Mistakes\n\n- ❌ Steps too large → ✅ One action per step\n- ❌ Skip verification → ✅ Every step has verify command\n- ❌ Implementation before test → ✅ TDD: test first\n- ❌ Vague actions → ✅ Include exact code\n```\n"
        }
      ]
    },
    {
      "name": "implement",
      "files": [
        {
          "path": "skills/implement/SKILL.md",
          "type": "skill",
          "content": "---\nname: aico-backend-implement\ndescription: |\n  Execute backend implementation with TDD (Test-Driven Development). Write failing test first, then implement, verify each step.\n\n  Use this skill when:\n  - User asks to \"implement this backend task\", \"implement backend\"\n  - Have an implementation plan ready and need to execute it\n  - Executing steps from /backend.plan output\n  - User says \"start coding backend\", \"write backend code\"\n  - User asks to \"use TDD\", \"write test first\", \"test-driven\" for backend code\n  - Fixing backend bugs (write failing test that reproduces bug first)\n\n  TDD Iron Law: NO PRODUCTION CODE WITHOUT A FAILING TEST FIRST\n  TDD Cycle: RED (write failing test) → Verify fails → GREEN (minimal code) → Verify passes → REFACTOR\n\n  Prerequisites:\n  - MUST have task file in docs/reference/backend/tasks/ (use /backend.tasks first if not exists)\n  - MUST read constraints.md before writing any code.\n  Flow: Check Task File → Read Constraints → TDD Cycle (RED→GREEN→REFACTOR) → Verify Each → Run All Tests → Update Task Status → Notify PM\n---\n\n# Implement\n\n## Language Configuration\n\nBefore generating any content, check `aico.json` in project root for `language` field to determine the output language. If not set, default to English.\n\n## Process\n\n0. **Check task file EXISTS** (MANDATORY):\n   - Look for `docs/reference/backend/tasks/{story-id}.md`\n   - If NOT exists → STOP and tell user: \"Please run /backend.tasks first to break down the story\"\n   - If exists → proceed to step 1\n\n1. **Read constraints FIRST**: Load `docs/reference/backend/constraints.md`\n2. **Execute each step in order**:\n   - If test step: write failing test, verify it fails\n   - If impl step: write code, verify test passes\n   - Run verification command\n   - If fail → fix before proceeding\n3. **After all steps**:\n   - Run full test suite\n   - Run type check\n   - Run linter\n4. **Update task status** in `docs/reference/backend/tasks/{story}.md`\n5. **Notify PM for acceptance** - Notify PM to verify (PM checks all related tasks and updates Story status)\n6. **Report completion** (user decides when to commit)\n\n## Execution Flow\n\n```\nCheck Task File → Read Constraints → Execute Steps (TDD) → Verify Each → Run All Tests → Mark Complete → Notify PM\n```\n\n## TDD Integration\n\n```\nStep N: Write failing test\n    ↓ Verify: test fails ❌\nStep N+1: Implement code\n    ↓ Verify: test passes ✅\n```\n\n## Step Execution Rules\n\n### Rule 1: Follow Constraints\n\n```typescript\n// ❌ Wrong: Ignore constraints\nconst password = user.password; // plaintext\n\n// ✅ Right: Follow security constraints\nconst passwordHash = await bcrypt.hash(password, 10);\n```\n\n### Rule 2: Verify Before Proceeding\n\nEach step has a Verify section - MUST run it and confirm expected output.\n\n### Rule 3: Test First (TDD)\n\n```markdown\n// ❌ Wrong order\nStep 1: Implement createUser method\nStep 2: Write test for createUser\n\n// ✅ Correct order\nStep 1: Write failing test for createUser\nStep 2: Implement createUser method\n```\n\n### Rule 4: No Skipping\n\n- Execute ALL steps in order\n- Do NOT combine steps\n- Do NOT skip verification\n\n## Post-Implementation Checklist\n\n1. **Run full test suite**: `npm test`\n2. **Run type check**: `npx tsc --noEmit`\n3. **Run linter**: `npm run lint`\n4. **Update task status** in tasks file\n5. **Notify PM**: Tell PM backend tasks are complete, request acceptance\n6. **Report completion** - user decides when to commit\n\n## Error Handling\n\n| Error Type   | Action               |\n| ------------ | -------------------- |\n| Test failure | Debug, fix, re-run   |\n| Type error   | Fix types, re-verify |\n| Lint error   | Fix style issues     |\n\n## Key Rules\n\n- ALWAYS read constraints before writing any code\n- MUST follow TDD: test first, then implementation\n- ALWAYS run verification for each step\n- MUST run full test suite before marking complete\n- MUST notify PM after completing all tasks (PM handles story verification)\n- Let user decide when to commit\n\n## Common Mistakes\n\n- ❌ Implement without task file → ✅ ALWAYS run /backend.tasks first to break down story\n- ❌ Skip reading constraints → ✅ ALWAYS read before coding\n- ❌ Write code before test → ✅ TDD: test first\n- ❌ Skip verification → ✅ Run verify command for each step\n- ❌ Skip full test suite → ✅ Run all tests before complete\n- ❌ Directly update story status → ✅ Notify PM, let PM verify and update story\n\n---\n\n## TDD Deep Dive\n\n### The TDD Iron Law\n\n```\nNO PRODUCTION CODE WITHOUT A FAILING TEST FIRST\n```\n\nWrite code before the test? **Delete it. Start over.**\n\n### Red-Green-Refactor Cycle\n\n```\nRED → Verify Fails → GREEN → Verify Passes → REFACTOR → Repeat\n```\n\n#### 1. RED - Write Failing Test\n\nWrite ONE minimal test showing expected behavior:\n\n```typescript\ntest('createUser hashes password before storing', async () => {\n  const user = await userService.createUser({\n    email: 'test@example.com',\n    password: 'plaintext123',\n  });\n\n  expect(user.passwordHash).not.toBe('plaintext123');\n  expect(await bcrypt.compare('plaintext123', user.passwordHash)).toBe(true);\n});\n```\n\n#### 2. Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.ts\n```\n\n#### 3. GREEN - Write Minimal Code\n\nWrite simplest code to pass the test. **Don't add features not in test.**\n\n#### 4. Verify GREEN - Watch It Pass\n\n```bash\nnpm test path/to/test.ts\n```\n\n#### 5. REFACTOR - Clean Up\n\nOnly after green. Keep tests passing.\n\n### Test Types\n\n| Type        | Purpose         | Example                          |\n| ----------- | --------------- | -------------------------------- |\n| Unit        | Single function | `authService.validatePassword()` |\n| Integration | With real DB    | `userRepository.create()`        |\n| API         | HTTP endpoints  | `POST /auth/register`            |\n\n### TDD Red Flags - STOP and Start Over\n\n- Code before test\n- Test passes immediately\n- Can't explain why test failed\n- Rationalizing \"just this once\"\n\n---\n\n## Iron Law\n\n**NO CODE WITHOUT APPROVED PLAN**\n\nThis rule is non-negotiable. Before writing code:\n\n1. Task breakdown must exist and be approved\n2. Acceptance criteria must be defined\n3. Dependencies must be identified and available\n\n### Rationalization Defense\n\n| Excuse                         | Reality                                     |\n| ------------------------------ | ------------------------------------------- |\n| \"It's a simple change\"         | Simple changes often have hidden complexity |\n| \"I'll document after coding\"   | Post-hoc documentation is always incomplete |\n| \"Tests can wait until later\"   | Untested code is broken code                |\n| \"I know what needs to be done\" | Assumptions without validation cause bugs   |\n"
        }
      ]
    }
  ],
  "commands": [
    {
      "name": "init",
      "files": [
        {
          "path": "commands/init.md",
          "type": "command",
          "content": "---\ndescription: Initialize backend constraints file for the project\n---\n\n# Initialize Backend Environment\n\nSet up the backend development environment by creating the constraints file.\n\n## Skills Used\n\n- `aico-backend-init` - Initialize backend environment with constraints template\n\n## Document Header Format\n\nAll generated documents MUST use this unified header format:\n\n```markdown\n# [Document Title]\n\n> Project: [project-name]\n> Created: YYYY-MM-DD\n> Last Updated: YYYY-MM-DD\n```\n\n## Steps\n\n1. **Check existing constraints**\n   - Look for `docs/reference/backend/constraints.md`\n   - If exists, ask user if they want to overwrite or skip\n\n2. **Create directory structure**\n\n   ```\n   docs/reference/backend/\n   ├── constraints.md      # Backend constraints (from template)\n   └── tasks/              # Task tracking directory\n   ```\n\n3. **Generate constraints file**\n   - Guide user through key decisions:\n     - Language/Runtime (Node.js, Python, Go, etc.)\n     - Framework (Express, FastAPI, Gin, etc.)\n     - Database (PostgreSQL, MongoDB, etc.)\n     - ORM/Query builder\n     - Testing framework\n     - API style (REST, GraphQL, gRPC)\n\n4. **Validate setup**\n   - Confirm constraints file created\n   - Confirm tasks directory exists\n\n## Output\n\n```\n✓ Created docs/reference/backend/constraints.md\n✓ Created docs/reference/backend/tasks/\n✓ Backend environment initialized\n```\n"
        }
      ]
    },
    {
      "name": "tasks",
      "files": [
        {
          "path": "commands/tasks.md",
          "type": "command",
          "content": "---\ndescription: Break down a PM story into backend tasks\n---\n\n# Break Down Story into Backend Tasks\n\nConvert a PM story/PRD into actionable backend tasks with progress tracking.\n\n## Usage\n\n```\n/backend.tasks [story-name]\n```\n\n## Arguments\n\n- `story-name` (optional): Name of the story to break down\n  - If not provided, list available stories and ask user to select\n\n## Steps\n\n1. **Locate story**\n   - Search in `docs/reference/pm/stories/`\n   - Search in `docs/reference/pm/versions/`\n   - If story-name provided, find matching file\n   - If not provided, list available stories for selection\n\n2. **Invoke task-breakdown skill**\n   - Use `aico-backend-task-breakdown` skill\n   - Read story/PRD content\n   - Analyze backend requirements\n   - Decompose into tasks following layered architecture\n\n3. **Create task file**\n   - Output to `docs/reference/backend/tasks/[story-name].md`\n   - Include progress tracking table\n   - Define each task with acceptance criteria\n\n## Output\n\n```\n✓ Found story: [story-name]\n✓ Analyzed backend requirements\n✓ Created docs/reference/backend/tasks/[story-name].md\n\nTasks created:\n1. Define data models (⏳ pending)\n2. Create database migrations (⏳ pending)\n3. Implement repository layer (⏳ pending)\n...\n```\n"
        }
      ]
    },
    {
      "name": "plan",
      "files": [
        {
          "path": "commands/plan.md",
          "type": "command",
          "content": "---\ndescription: Create atomic implementation plan for a backend task\n---\n\n# Create Implementation Plan\n\nConvert a single backend task into atomic 2-5 minute implementation steps.\n\n## Usage\n\n```\n/backend.plan [task-number]\n```\n\n## Arguments\n\n- `task-number` (optional): Task number from the task list\n  - If not provided, show current task list and ask user to select\n\n## Prerequisites\n\n- Task file exists at `docs/reference/backend/tasks/[story].md`\n- Constraints file exists at `docs/reference/backend/constraints.md`\n\n## Steps\n\n1. **Locate task**\n   - Read task file from `docs/reference/backend/tasks/`\n   - If task-number provided, find that task\n   - If not provided, show pending tasks for selection\n\n2. **Read constraints**\n   - Load `docs/reference/backend/constraints.md`\n   - Understand tech stack, patterns, conventions\n\n3. **Invoke plan skill**\n   - Use `aico-backend-plan` skill\n   - Break task into atomic steps (2-5 minutes each)\n   - Each step includes:\n     - Files to create/modify\n     - Exact action to take\n     - Verification command\n\n4. **Present plan**\n   - Show step-by-step implementation plan\n   - Include TDD steps (test first)\n   - Include verification for each step\n\n## Output\n\n```markdown\n# [Task Name] - Implementation Plan\n\n> Project: [project-name]\n> Created: YYYY-MM-DD\n> Task: [task description]\n\n## Step 1: Define types\n\n**Files**: Create `src/types/user.ts`\n**Action**: [code snippet]\n**Verify**: `npx tsc --noEmit` → No errors\n\n## Step 2: Write failing test\n\n**Files**: Create `src/services/__tests__/user.test.ts`\n**Action**: [test code]\n**Verify**: `npm test user.test.ts` → 1 failing test\n\n...\n\nReady to implement? Use the implement skill to execute this plan.\n```\n"
        }
      ]
    }
  ],
  "docs": [],
  "dependencies": [
    "@the-aico/_shared/code-review",
    "@the-aico/_shared/subagent-driven",
    "@the-aico/_shared/worktree"
  ]
}
